# How The Exploit Verification Works

## Overview

The exploit demonstrates a storage collision vulnerability where the `MaliciousContract` writes to storage slot 0, which overwrites the `SafeProxy`'s implementation address.

## Step-by-Step Verification

### Step 1: Initial State
```javascript
const implBefore = await safeProxy.getImplementation()
// Returns: The SafeImplementation address (e.g., 0x123...)
```
**What this checks:** Reads storage slot 0 of the proxy, which holds the implementation address.

### Step 2: Deploy Vulnerable Proxy
```javascript
const attackedProxy = await ProxyFactory.deploy(addresses.maliciousContract)
// deployed to: 0x456...
```
**What this does:** Creates a new proxy that points to `MaliciousContract` instead of `SafeImplementation`.

**Storage layout:**
- Proxy slot 0 = `address implementation` → Now points to `MaliciousContract`
- `MaliciousContract` slot 0 = `uint256 _transfer` → Currently 0

### Step 3: Call transfer() on Proxy
```javascript
const data = iface.encodeFunctionData("transfer", [account, 0])
await signer.sendTransaction({
  to: attackedProxyAddress,
  data: data
})
```

**What happens:**
1. Proxy receives the call with `transfer(address, uint256)` data
2. Proxy's fallback function activates (because there's no direct `transfer()` function)
3. Proxy delegatecalls to `MaliciousContract` (the current implementation)
4. `MaliciousContract.transfer()` executes in the **proxy's storage context**
5. Line executes: `_transfer = uint256(uint160(recipient))`
6. This writes to the proxy's storage slot 0 (which is the `implementation` variable)

### Step 4: Verification - Check Storage Slot 0
```javascript
const implAfter = await attackedProxyContract.getImplementation()
```

**What we're checking:**
- Read the same storage slot 0 that `MaliciousContract.transfer()` wrote to
- Compare the before and after values

**Expected result:**
- **Before:** Implementation address points to `MaliciousContract` (0x456...)
- **After:** Implementation address has been overwritten to `0x[your-wallet-address]`

## How We Know It Was Overwritten

### The Proof:

1. **Before transfer():** Storage slot 0 contains the implementation address
   ```
   Slot 0 = 0x0000000000000000000000001234567890abcdef... (MaliciousContract address)
   ```

2. **After transfer():** Storage slot 0 now contains your wallet address
   ```
   Slot 0 = 0x000000000000000000000000YOURWALLETADDRESS
   ```

3. **Verification:**
   ```javascript
   if (addresses.maliciousContract.toLowerCase() !== implAfter.toLowerCase()) {
       // ✅ EXPLOIT CONFIRMED!
       // The address changed from MaliciousContract to your wallet
   }
   ```

## What This Proves

✅ **Storage slot collision works:** Both contracts use slot 0
✅ **Delegatecall context:** Code runs in the caller's (proxy) storage
✅ **Implementation can be overwritten:** By calling the right function
✅ **The vulnerability is real:** Proxy storage can be manipulated

## Visual Representation

```
┌─────────────────────────────────────────────────┐
│ Step 1: Original Proxy State                    │
├─────────────────────────────────────────────────┤
│ Storage Slot 0: [SafeImplementation address]    │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Step 2: Deploy New Proxy                        │
├─────────────────────────────────────────────────┤
│ Storage Slot 0: [MaliciousContract address]    │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Step 3: Call transfer()                         │
├─────────────────────────────────────────────────┤
│ MaliciousContract.transfer() writes to slot 0:  │
│ _transfer = uint256(uint160(recipient))         │
│ This overwrites the proxy's slot 0!             │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Step 4: Verification                           │
├─────────────────────────────────────────────────┤
│ Storage Slot 0: [Your Wallet Address]           │
│                                                  │
│ ✅ Implementation address overwritten!           │
└─────────────────────────────────────────────────┘
```

## The Key Insight

**Why this works:**
- When `MaliciousContract` writes to `_transfer` (its slot 0), it's actually writing to the proxy's slot 0 (implementation)
- This happens because of delegatecall - the code runs in the proxy's storage context
- The `transfer()` function appears legitimate but is maliciously overwriting critical storage

**Why it's dangerous:**
- An attacker can change what contract the proxy calls
- They can redirect all future calls to their own malicious contract
- Complete control of the proxy is achieved

## Console Logs

All of this is logged to the browser console (F12) in real-time:
- Each step of deployment
- Transaction hashes
- Before/after addresses
- Success/failure status

## UI Display

The UI shows:
1. **Live logs** - Every step as it happens
2. **Before address** - Yellow box showing original implementation
3. **After address** - Red box showing the new (overwritten) implementation
4. **Status updates** - Progress through each step

